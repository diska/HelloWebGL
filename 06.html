<style>textarea{background-color: bisque;}</style>
<h1>Framebuffer/txtImage2D</h1>
<div id="DIV"></div><hr/>
pg0:<input id="SLD0" type="range" min="0" max="6.28" step="0.02"></br>
pg1:<input id="SLD1" type="range" min="0" max="6.28" step="0.02"></br>
<textarea id="AREA" cols="80" rows="20"></textarea>
<script>
var CNVS=document.createElement("canvas");	DIV.appendChild(CNVS);
CNVS.width=256, CNVS.height=256;
var cx0=CNVS.getContext("webgl");
const vsrc0=`attribute vec4 p;void main(){gl_PointSize=64.;gl_Position=p;}`;
const fsrc0=`void main(){if(length(gl_PointCoord-0.5)>0.5)discard;gl_FragColor=vec4(1);}`;
var pg0=getPg(cx0, vsrc0, fsrc0);AREA.value =chkPg(cx0, pg0);
var pg0p=cx0.getAttribLocation(pg0, "p");
const vsrc1=`attribute vec4 p;void main(){gl_PointSize=64.;gl_Position=p;}`;
const fsrc1=`precision mediump float;uniform sampler2D tx0;
void main(){if(length(gl_PointCoord-0.5)>0.5)discard;gl_FragColor=texture2D(tx0,gl_PointCoord);}`;
var pg1=getPg(cx0, vsrc1, fsrc1);AREA.value+=chkPg(cx0, pg1);
var pg1p=cx0.getAttribLocation(pg1, "p");
var pg1tx0=cx0.getUniformLocation(pg1, "tx0");
//
const FRAME=0x8d40,RENDE=0x8d41,COLOR=0x8ce0,DEPTH=0x8d00,STENC=0x8d20;
const TXT2D=0x0de1,TXT00=0x84c0,TDIC0=0x8515;
const ATYPE=0x8cd0,ANAME=0x8cd1,ATLVL=0x8cd2,ATFAC=0x8cd3;
var da0=new Uint8Array(256*256*4);
var tx0=cx0.createTexture();
cx0.activeTexture(TXT00+0);cx0.bindTexture(TXT2D, tx0);
cx0.texImage2D(TXT2D,0,cx0.RGBA, 256,256,0,cx0.RGBA,cx0.UNSIGNED_BYTE,da0);
var fb0=cx0.createFramebuffer();
cx0.bindFramebuffer(FRAME,fb0);
cx0.framebufferTexture2D(FRAME,COLOR, TXT2D,tx0,0);AREA.value+=chkFb(cx0, fb0);
//
function draw(){
	var t0=SLD0.valueAsNumber;
	var t1=SLD1.valueAsNumber;
	cx0.bindFramebuffer(FRAME,fb0);{
		cx0.useProgram(pg0);
		cx0.vertexAttrib4fv(pg0p, [Math.cos(t0)/2, Math.sin(t0)/2, 0,1]);
		cx0.clearColor(0.2,0.4,0,1);	cx0.clear(0x4000);
		cx0.drawArrays(0, 0,1);
	}
	cx0.activeTexture(TXT00+0);	cx0.generateMipmap(TXT2D);
	cx0.bindFramebuffer(FRAME,null);{
		cx0.useProgram(pg1);
		cx0.uniform1i(pg1tx0, 0);
		cx0.vertexAttrib4fv(pg1p, [Math.cos(t1)/2, Math.sin(t1)/2, 0,1]);
		cx0.clearColor(0.0,0.3,0,1);	cx0.clear(0x4000);
		cx0.drawArrays(0, 0,1);
	}
};	draw();
SLD0.addEventListener("input", draw);
SLD1.addEventListener("input", draw);
//
function getPg(cx, vsrc, fsrc){
	const SHADV=0x8b31, SHADF=0x8b30;
	var vs=cx.createShader(SHADV);cx.shaderSource(vs, vsrc);cx.compileShader(vs);
	var fs=cx.createShader(SHADF);cx.shaderSource(fs, fsrc);cx.compileShader(fs);
	var pg=cx.createProgram();cx.attachShader(pg, vs);cx.attachShader(pg, fs);
	cx.linkProgram(pg);
	return pg;
}
function chkPg(cx, pg){
	var vs=cx.getAttachedShaders(pg)[0], fs=cx.getAttachedShaders(pg)[1];
	var str="";
	str+=`Compile log for VS ${vs}:\n${cx.getShaderInfoLog(vs)}`;
	str+=`Compile log for FS ${fs}:\n${cx.getShaderInfoLog(fs)}`;
	str+=`Link log for PG ${pg}:\n${cx.getProgramInfoLog(pg)}`;
	return str;
}
function chkFb(cx,fb){
	const stat={};
	const COMPL=0x8cd5,INATT=0x8cd6,INMIS=0x8cd7,INDIM=0x8cd9,UNSUP=0x8cdd;
	stat[COMPL]="FRAMEBUFFER_COMPLETE";
	stat[INATT]="FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
	stat[INMIS]="FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
	stat[INDIM]="FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
	stat[UNSUP]="FRAMEBUFFER_UNSUPPORTED";
	return `FramebufferStatus(fb)   =${stat[cx.checkFramebufferStatus(FRAME)]}\n`;
}
</script>